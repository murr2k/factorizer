# Elliptic Curve Method (ECM) Implementation

## Overview

This document describes the GPU-accelerated Elliptic Curve Method (ECM) implementation for the CUDA Factorizer project. ECM is a powerful integer factorization algorithm particularly effective at finding medium-sized factors (10-20 digits).

## Implementation Details

### Core Components

1. **Montgomery Curves**
   - Uses Montgomery curve form: `By² = x³ + Ax² + x` (with B=1)
   - Projective coordinates (X:Z) for efficiency
   - No Y-coordinate needed for scalar multiplication

2. **Point Arithmetic**
   - `ecm_point_double()`: Efficient point doubling
   - `ecm_point_add()`: Differential addition using P-Q
   - `ecm_scalar_multiply()`: Montgomery ladder (constant-time)

3. **Parallel Processing**
   - 32-64 curves processed simultaneously per kernel
   - Each thread handles one curve independently
   - cuRAND for high-quality random curve generation

4. **Two-Stage Algorithm**
   - **Stage 1**: Multiply by smooth numbers up to B1 (50,000)
   - **Stage 2**: Baby-step giant-step up to B2 (5,000,000)

### Key Features

- **Memory Efficiency**: Optimized data structures for GPU
- **GCD Accumulation**: Periodic GCD checks to avoid overflow
- **Auto-Detection**: Intelligent selection of ECM for suitable numbers
- **Integration**: Seamless integration with existing factorizer

## Usage

### Command Line

```bash
# Force ECM algorithm
./factorizer_ecm -a ecm 1099511627791

# Auto-select (may choose ECM)
./factorizer_ecm 123456789012345678901

# Specify number of curves
./factorizer_ecm -a ecm -c 2000 18446744073709551557

# Run benchmark
./factorizer_ecm --benchmark
```

### API Functions

```cuda
// Main factorization function
bool ecm_factor(uint128_t n, uint128_t& factor, int max_curves = 1000);

// Check if ECM is suitable for a number
bool ecm_is_suitable(uint128_t n);
```

## Performance Characteristics

### Advantages
- Excellent for 10-20 digit factors
- Highly parallelizable
- Memory efficient
- Predictable runtime

### Limitations
- Less effective for very small or very large factors
- Probabilistic (may not find factors)
- Requires many curves for harder numbers

## Algorithm Parameters

| Parameter | Default | Description |
|-----------|---------|-------------|
| B1 | 50,000 | Stage 1 smoothness bound |
| B2 | 5,000,000 | Stage 2 smoothness bound |
| Curves/batch | 64 | Parallel curves per kernel |
| Baby steps | 2048 | Stage 2 baby steps |
| Giant steps | 2048 | Stage 2 giant steps |

## Implementation Files

- `ecm_cuda.cu`: Main ECM implementation
- `ecm_cuda.cuh`: Header file with declarations
- `test_ecm.cu`: Comprehensive test suite
- `factorizer_cuda_v2.2_ecm.cu`: Integrated factorizer

## Build Instructions

```bash
# Build everything
./build_ecm.sh

# Or manually
make -f Makefile.ecm all

# Run tests
./test_ecm

# Run demo
./demo_ecm.sh
```

## Technical Details

### Montgomery Ladder
The implementation uses the Montgomery ladder for scalar multiplication, providing:
- Constant-time operation (resistant to timing attacks)
- Efficient doubling and differential addition
- No need for Y-coordinates

### Curve Generation
Random curves are generated by:
1. Selecting random point (x,y)
2. Computing curve parameter A from the point
3. Ensuring the curve has good properties

### Stage 2 Optimization
The baby-step giant-step algorithm in Stage 2:
- Precomputes baby steps: Q, 2Q, ..., 2048Q
- Tests differences with giant steps
- Reduces scalar multiplications needed

## Future Improvements

1. **FFT Stage 2**: Implement FFT-based Stage 2 for better performance
2. **Curve Selection**: Implement Suyama's parameterization
3. **B1/B2 Optimization**: Dynamic bound selection based on number size
4. **Memory Pool**: Shared memory pool for curve storage
5. **Multi-GPU**: Support for multiple GPUs

## References

1. Lenstra, H.W. Jr. (1987). "Factoring integers with elliptic curves"
2. Montgomery, P.L. (1987). "Speeding the Pollard and elliptic curve methods"
3. Brent, R.P. et al. (2000). "Factorization of the tenth Fermat number"